/*!
 * \file      LoRaMacCrypto.c
 *
 * \brief     LoRa MAC layer cryptography implementation
 *
 * \copyright Revised BSD License, see LICENSE file in this directory.
 *
 * \code
 *                ______                              _
 *               / _____)             _              | |
 *              ( (____  _____ ____ _| |_ _____  ____| |__
 *               \____ \| ___ |    (_   _) ___ |/ ___)  _ \
 *               _____) ) ____| | | || |_| ____( (___| | | |
 *              (______/|_____)_|_|_| \__)_____)\____)_| |_|
 *              (C)2013-2017 Semtech
 *
 *               ___ _____ _   ___ _  _____ ___  ___  ___ ___
 *              / __|_   _/_\ / __| |/ / __/ _ \| _ \/ __| __|
 *              \__ \ | |/ _ \ (__| ' <| _| (_) |   / (__| _|
 *              |___/ |_/_/ \_\___|_|\_\_| \___/|_|_\\___|___|
 *              embedded.connectivity.solutions===============
 *
 * \endcode
 *
 * \author    Miguel Luis ( Semtech )
 *
 * \author    Gregory Cristian ( Semtech )
 *
 * \author    Daniel Jaeckle ( STACKFORCE )
 *
 * \author    Johannes Bruder ( STACKFORCE )
 */
#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>

#include "cmac.h"
#include "utilities.h"
#include "se-identity.h"

#include "LoRaMacCrypto.h"

/*
 * CMAC/AES Message Integrity Code (MIC) Block B0 size
 */
#define MIC_BLOCK_BX_SIZE 16

/*
 * Maximum size of the message that can be handled by the crypto operations
 */
#define CRYPTO_MAXMESSAGE_SIZE 256

LoRaMacCrypto::LoRaMacCrypto ()
{
  m_SeNvm = {/*!
        * end-device IEEE EUI (big endian)
        *
        * \remark In this application the value is automatically generated by
        *         calling BoardGetUniqueId function
        */
             .DevEui = LORAWAN_DEVICE_EUI,
             /*!
        * App/Join server IEEE EUI (big endian)
        */
             .JoinEui = LORAWAN_JOIN_EUI,
             /*!
        * Secure-element pin (big endian)
        */
             .Pin = SECURE_ELEMENT_PIN,
             /*!
        * LoRaWAN key list
        */
             .KeyList = SOFT_SE_KEY_LIST};
}

LoRaMacCrypto::~LoRaMacCrypto ()
{
}

LoRaMacCryptoStatus_t
LoRaMacCrypto::PayloadEncrypt (uint8_t *buffer, int16_t size, KeyIdentifier_t keyID,
                               uint32_t address, uint8_t dir, uint32_t frameCounter)
{
  if (buffer == 0)
    {
      return LORAMAC_CRYPTO_ERROR_NPE;
    }

  uint8_t bufferIndex = 0;
  uint16_t ctr = 1;
  uint8_t sBlock[16] = {0};
  uint8_t aBlock[16] = {0};

  aBlock[0] = 0x01;

  aBlock[5] = dir;

  aBlock[6] = address & 0xFF;
  aBlock[7] = (address >> 8) & 0xFF;
  aBlock[8] = (address >> 16) & 0xFF;
  aBlock[9] = (address >> 24) & 0xFF;

  aBlock[10] = frameCounter & 0xFF;
  aBlock[11] = (frameCounter >> 8) & 0xFF;
  aBlock[12] = (frameCounter >> 16) & 0xFF;
  aBlock[13] = (frameCounter >> 24) & 0xFF;

  while (size > 0)
    {
      aBlock[15] = ctr & 0xFF;
      ctr++;
      if (SecureElementAesEncrypt (aBlock, 16, keyID, sBlock) != SECURE_ELEMENT_SUCCESS)
        {
          return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
        }

      for (uint8_t i = 0; i < ((size > 16) ? 16 : size); i++)
        {
          buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
        }
      size -= 16;
      bufferIndex += 16;
    }

  return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t
LoRaMacCrypto::ComputeCmacB0 (uint8_t *msg, uint16_t len, KeyIdentifier_t keyID, bool isAck,
                              uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t *cmac)
{
  if ((msg == 0) || (cmac == 0))
    {
      return LORAMAC_CRYPTO_ERROR_NPE;
    }
  if (len > CRYPTO_MAXMESSAGE_SIZE)
    {
      return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
    }

  uint8_t micBuff[MIC_BLOCK_BX_SIZE];

  // Initialize the first Block
  PrepareB0 (len, keyID, isAck, dir, devAddr, fCnt, micBuff);

  if (SecureElementComputeAesCmac (micBuff, msg, len, keyID, cmac) != SECURE_ELEMENT_SUCCESS)
    {
      return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }
  return LORAMAC_CRYPTO_SUCCESS;
}

SecureElementStatus_t
LoRaMacCrypto::SecureElementAesEncrypt (uint8_t *buffer, uint16_t size, KeyIdentifier_t keyID,
                                        uint8_t *encBuffer)
{
  if (buffer == NULL || encBuffer == NULL)
    {
      return SECURE_ELEMENT_ERROR_NPE;
    }

  // Check if the size is divisible by 16,
  if ((size % 16) != 0)
    {
      return SECURE_ELEMENT_ERROR_BUF_SIZE;
    }

  aes_context aesContext;
  memset1 (aesContext.ksch, '\0', 240);

  Key_t *pItem;
  SecureElementStatus_t retval = GetKeyByID (keyID, &pItem);

  if (retval == SECURE_ELEMENT_SUCCESS)
    {
      aes_set_key (pItem->KeyValue, 16, &aesContext);

      uint8_t block = 0;

      while (size != 0)
        {
          aes_encrypt (&buffer[block], &encBuffer[block], &aesContext);
          block = block + 16;
          size = size - 16;
        }
    }
  return retval;
}

LoRaMacCryptoStatus_t
LoRaMacCrypto::PrepareB0 (uint16_t msgLen, KeyIdentifier_t keyID, bool isAck, uint8_t dir,
                          uint32_t devAddr, uint32_t fCnt, uint8_t *b0)
{
  if (b0 == 0)
    {
      return LORAMAC_CRYPTO_ERROR_NPE;
    }

  b0[0] = 0x49;

  b0[1] = 0x00;
  b0[2] = 0x00;

  b0[3] = 0x00;
  b0[4] = 0x00;

  b0[5] = dir;

  b0[6] = devAddr & 0xFF;
  b0[7] = (devAddr >> 8) & 0xFF;
  b0[8] = (devAddr >> 16) & 0xFF;
  b0[9] = (devAddr >> 24) & 0xFF;

  b0[10] = fCnt & 0xFF;
  b0[11] = (fCnt >> 8) & 0xFF;
  b0[12] = (fCnt >> 16) & 0xFF;
  b0[13] = (fCnt >> 24) & 0xFF;

  b0[14] = 0x00;

  b0[15] = msgLen & 0xFF;

  return LORAMAC_CRYPTO_SUCCESS;
}

SecureElementStatus_t
LoRaMacCrypto::SecureElementComputeAesCmac (uint8_t *micBxBuffer, uint8_t *buffer, uint16_t size,
                                            KeyIdentifier_t keyID, uint32_t *cmac)
{
  if (keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS)
    {
      // Never accept multicast key identifier for cmac computation
      return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }
  return ComputeCmac (micBxBuffer, buffer, size, keyID, cmac);
}

SecureElementStatus_t
LoRaMacCrypto::ComputeCmac (uint8_t *micBxBuffer, uint8_t *buffer, uint16_t size,
                            KeyIdentifier_t keyID, uint32_t *cmac)
{
  if ((buffer == NULL) || (cmac == NULL))
    {
      return SECURE_ELEMENT_ERROR_NPE;
    }

  uint8_t Cmac[16];
  AES_CMAC_CTX aesCmacCtx[1];

  AES_CMAC_Init (aesCmacCtx);

  Key_t *keyItem;
  SecureElementStatus_t retval = GetKeyByID (keyID, &keyItem);

  if (retval == SECURE_ELEMENT_SUCCESS)
    {
      AES_CMAC_SetKey (aesCmacCtx, keyItem->KeyValue);

      if (micBxBuffer != NULL)
        {
          AES_CMAC_Update (aesCmacCtx, micBxBuffer, 16);
        }

      AES_CMAC_Update (aesCmacCtx, buffer, size);

      AES_CMAC_Final (Cmac, aesCmacCtx);

      // Bring into the required format
      *cmac = (uint32_t) ((uint32_t) Cmac[3] << 24 | (uint32_t) Cmac[2] << 16 |
                          (uint32_t) Cmac[1] << 8 | (uint32_t) Cmac[0]);
    }

  return retval;
}

SecureElementStatus_t
LoRaMacCrypto::GetKeyByID (KeyIdentifier_t keyID, Key_t **keyItem)
{
  for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
      if (m_SeNvm.KeyList[i].KeyID == keyID)
        {
          *keyItem = &(m_SeNvm.KeyList[i]);
          return SECURE_ELEMENT_SUCCESS;
        }
    }
  return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
}
